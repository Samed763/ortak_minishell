#include "minishell.h"

// Forward declaration
void execute_pipeline(t_data *data, int cmd_count);

void executor(t_data *data)
{
    if (!data || !data->parsed || !data->parsed->args || !data->parsed->args[0])
        return;

    // Count number of commands (pipe segments)
    int cmd_count = 0;
    while (data->parsed->args[cmd_count])
        cmd_count++;

    // Handle heredoc first if present
    if (data->parsed->heredoc)
    {
        handle_heredoc(data);
        if (g_signal_received == SIGINT)
        {
            data->last_exit_status = 130;
            return;
        }
    }

    if (cmd_count == 1)
    {
        // Single command - no pipes
        char **cmd = data->parsed->args[0];
        if (!cmd || !cmd[0])
            return;

        // Check if it's a builtin command
        if (is_builtin(cmd[0]))
        {
            // Setup redirections for builtins
            int saved_stdin = dup(STDIN_FILENO);
            int saved_stdout = dup(STDOUT_FILENO);
            
            setup_redirections(data);
            data->last_exit_status = execute_builtin(data, cmd, 0);
            
            // Restore original stdin/stdout
            dup2(saved_stdin, STDIN_FILENO);
            dup2(saved_stdout, STDOUT_FILENO);
            close(saved_stdin);
            close(saved_stdout);
        }
        else
        {
            // Execute external command in child process
            pid_t pid = fork();
            if (pid == 0)
            {
                // Child process
                setup_redirections(data);
                execute_external(data, cmd, NULL);
            }
            else if (pid > 0)
            {
                // Parent process - wait for child
                int status;
                waitpid(pid, &status, 0);
                
                if (WIFEXITED(status))
                    data->last_exit_status = WEXITSTATUS(status);
                else if (WIFSIGNALED(status))
                {
                    int sig = WTERMSIG(status);
                    if (sig == SIGINT)
                        data->last_exit_status = 130;
                    else if (sig == SIGQUIT)
                        data->last_exit_status = 131;
                    else
                        data->last_exit_status = 128 + sig;
                }
            }
            else
            {
                perror("fork");
                data->last_exit_status = 1;
            }
        }
    }
    else
    {
        // Multiple commands with pipes
        execute_pipeline(data, cmd_count);
    }
}

void execute_pipeline(t_data *data, int cmd_count)
{
    int *pipe_fds = malloc(sizeof(int) * (cmd_count - 1) * 2);
    pid_t *pids = malloc(sizeof(pid_t) * cmd_count);
    
    // Create all pipes
    for (int i = 0; i < cmd_count - 1; i++)
    {
        if (pipe(pipe_fds + i * 2) == -1)
        {
            perror("pipe");
            free(pipe_fds);
            free(pids);
            return;
        }
    }

    // Setup signals for execution
    setup_signals_for_execution();

    // Execute each command
    for (int i = 0; i < cmd_count; i++)
    {
        char **cmd = data->parsed->args[i];
        if (!cmd || !cmd[0])
            continue;

        pids[i] = fork();
        if (pids[i] == 0)
        {
            // Child process - restore default signal handlers
            restore_signals();
            
            // Setup pipes
            setup_pipes(data, i, cmd_count, pipe_fds);
            
            // Setup redirections only for first and last commands
            if (i == 0 || i == cmd_count - 1)
                setup_redirections(data);

            // Close all pipe fds in child
            for (int j = 0; j < (cmd_count - 1) * 2; j++)
                close(pipe_fds[j]);

            if (is_builtin(cmd[0]))
            {
                exit(execute_builtin(data, cmd, i));
            }
            else
            {
                execute_external(data, cmd, NULL);
            }
        }
        else if (pids[i] < 0)
        {
            perror("fork");
        }
    }

    // Close all pipe fds in parent
    for (int i = 0; i < (cmd_count - 1) * 2; i++)
        close(pipe_fds[i]);

    // Wait for all children and handle signals
    int last_status = 0;
    for (int i = 0; i < cmd_count; i++)
    {
        int status;
        waitpid(pids[i], &status, 0);
        
        if (WIFEXITED(status))
        {
            if (i == cmd_count - 1) // Last command determines exit status
                last_status = WEXITSTATUS(status);
        }
        else if (WIFSIGNALED(status))
        {
            int sig = WTERMSIG(status);
            if (sig == SIGINT)
                last_status = 130;
            else if (sig == SIGQUIT)
                last_status = 131;
            else
                last_status = 128 + sig;
        }
    }

    data->last_exit_status = last_status;
    
    // Restore interactive signal handling
    setup_signals();
    
    free(pipe_fds);
    free(pids);
}

int execute_builtin(t_data *data, char **cmd, int cmd_idx)
{
    if (ft_strcmp(cmd[0], "echo") == 0)
        return cmd_echo(cmd);
    else if (ft_strcmp(cmd[0], "cd") == 0)
        return cmd_cd(data, cmd);
    else if (ft_strcmp(cmd[0], "pwd") == 0)
        return cmd_pwd();
    else if (ft_strcmp(cmd[0], "env") == 0)
        return cmd_env(data);
    else if (ft_strcmp(cmd[0], "export") == 0)
        return cmd_export(data, cmd);
    else if (ft_strcmp(cmd[0], "unset") == 0)
        return cmd_unset(data, cmd);
    else if (ft_strcmp(cmd[0], "exit") == 0)
        return cmd_exit(data, cmd);
    
    return 1;
}

void execute_external(t_data *data, char **cmd, char **envp)
{
    char *path = NULL;
    char *full_path = NULL;

    // If command contains '/', use it directly
    if (strchr(cmd[0], '/'))
    {
        full_path = ft_strdup(cmd[0]);
    }
    else
    {
        // Search in PATH
        path = get_value_by_key(data->env->env_dictionary, "PATH");
        if (path)
        {
            char **paths = ft_split(path, ':');
            int i = 0;
            while (paths[i])
            {
                char *temp = ft_strjoin(paths[i], "/");
                full_path = ft_strjoin(temp, cmd[0]);
                free(temp);
                
                if (access(full_path, F_OK) == 0)
                    break;
                
                free(full_path);
                full_path = NULL;
                i++;
            }
            
            // Free paths array
            i = 0;
            while (paths[i])
                free(paths[i++]);
            free(paths);
        }
    }

    if (!full_path)
    {
        printf("%s: command not found\n", cmd[0]);
        exit(127);
    }

    // Convert env dictionary to envp format
    int env_count = 0;
    while (data->env->env_dictionary[env_count])
        env_count++;

    char **new_envp = malloc(sizeof(char *) * (env_count + 1));
    for (int i = 0; i < env_count; i++)
    {
        char *key = data->env->env_dictionary[i][0];
        char *value = data->env->env_dictionary[i][1];
        char *temp = ft_strjoin(key, "=");
        new_envp[i] = ft_strjoin(temp, value);
        free(temp);
    }
    new_envp[env_count] = NULL;

    execve(full_path, cmd, new_envp);
    perror("execve");
    exit(127);
}

int is_builtin(char *cmd)
{
    if (!cmd)
        return 0;
    
    return (ft_strcmp(cmd, "echo") == 0 ||
            ft_strcmp(cmd, "cd") == 0 ||
            ft_strcmp(cmd, "pwd") == 0 ||
            ft_strcmp(cmd, "env") == 0 ||
            ft_strcmp(cmd, "export") == 0 ||
            ft_strcmp(cmd, "unset") == 0 ||
            ft_strcmp(cmd, "exit") == 0);
}

void setup_redirections(t_data *data)
{
    // Handle input redirection
    if (data->parsed->input_file)
    {
        int fd = open(data->parsed->input_file, O_RDONLY);
        if (fd == -1)
        {
            perror(data->parsed->input_file);
            exit(1);
        }
        dup2(fd, STDIN_FILENO);
        close(fd);
    }

    // Handle heredoc
    if (data->parsed->heredoc && data->parsed->heredoc_content)
    {
        int pipe_fd[2];
        if (pipe(pipe_fd) == -1)
        {
            perror("pipe");
            exit(1);
        }
        
        write(pipe_fd[1], data->parsed->heredoc_content, ft_strlen(data->parsed->heredoc_content));
        close(pipe_fd[1]);
        dup2(pipe_fd[0], STDIN_FILENO);
        close(pipe_fd[0]);
    }

    // Handle output redirection
    if (data->parsed->output_file)
    {
        int flags = O_WRONLY | O_CREAT;
        if (data->parsed->append)
            flags |= O_APPEND;
        else
            flags |= O_TRUNC;

        int fd = open(data->parsed->output_file, flags, 0644);
        if (fd == -1)
        {
            perror(data->parsed->output_file);
            exit(1);
        }
        dup2(fd, STDOUT_FILENO);
        close(fd);
    }
}

void setup_pipes(t_data *data, int cmd_idx, int cmd_count, int *pipe_fds)
{
    // If not the first command, read from previous pipe
    if (cmd_idx > 0)
    {
        dup2(pipe_fds[(cmd_idx - 1) * 2], STDIN_FILENO);
    }

    // If not the last command, write to next pipe
    if (cmd_idx < cmd_count - 1)
    {
        dup2(pipe_fds[cmd_idx * 2 + 1], STDOUT_FILENO);
    }
}

void handle_heredoc(t_data *data)
{
    if (!data->parsed->heredoc_limiter)
        return;

    // Setup signals for heredoc
    setup_signals_for_heredoc();

    char *line;
    char *content = ft_strdup("");
    
    printf("heredoc> ");
    while ((line = readline("")))
    {
        // Check if signal was received
        if (g_signal_received == SIGINT)
        {
            free(line);
            free(content);
            setup_signals(); // Restore interactive signals
            return;
        }
        
        if (ft_strcmp(line, data->parsed->heredoc_limiter) == 0)
        {
            free(line);
            break;
        }
        
        char *temp = ft_strjoin(content, line);
        free(content);
        content = ft_strjoin(temp, "\n");
        free(temp);
        free(line);
        
        printf("heredoc> ");
    }
    
    data->parsed->heredoc_content = content;
    
    // Restore interactive signals
    setup_signals();
}
